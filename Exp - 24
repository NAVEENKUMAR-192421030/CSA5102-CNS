#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>


#define BLOCK_SIZE 64
#define KEY_SIZE 64
#define ROUNDS 16


int IP[] = {58, 50, 42, 34, 26, 18, 10, 2,
            60, 52, 44, 36, 28, 20, 12, 4,
            62, 54, 46, 38, 30, 22, 14, 6,
            64, 56, 48, 40, 32, 24, 16, 8,
            57, 49, 41, 33, 25, 17, 9, 1,
            59, 51, 43, 35, 27, 19, 11, 3,
            61, 53, 45, 37, 29, 21, 13, 5,
            63, 55, 47, 39, 31, 23, 15, 7};


int FP[] = {40, 8, 48, 16, 56, 24, 64, 32,
            39, 7, 47, 15, 55, 23, 63, 31,
            38, 6, 46, 14, 54, 22, 62, 30,
            37, 5, 45, 13, 53, 21, 61, 29,
            36, 4, 44, 12, 52, 20, 60, 28,
            35, 3, 43, 11, 51, 19, 59, 27,
            34, 2, 42, 10, 50, 18, 58, 26,
            33, 1, 41, 9, 49, 17, 57, 25};

// Key permutation tables
int PC1[] = {57, 49, 41, 33, 25, 17, 9,
             1, 58, 50, 42, 34, 26, 18,
             10, 2, 59, 51, 43, 35, 27,
             19, 11, 3, 60, 52, 44, 36,
             63, 55, 47, 39, 31, 23, 15,
             7, 62, 54, 46, 38, 30, 22,
             14, 6, 61, 53, 45, 37, 29,
             21, 13, 5, 28, 20, 12, 4};

int PC2[] = {14, 17, 11, 24, 1, 5,
             3, 28, 15, 6, 21, 10,
             23, 19, 12, 4, 26, 8,
             16, 7, 27, 20, 13, 2,
             41, 52, 31, 37, 47, 55,
             30, 40, 51, 45, 33, 48,
             44, 49, 39, 56, 34, 53,
             46, 42, 50, 36, 29, 32};

// Shift schedule for key generation
int shift_schedule[] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};

// Function prototypes
void generate_subkeys(uint64_t key, uint64_t subkeys[]);
void modify_subkey_bits(uint64_t subkeys[], int round, int bit1, int bit2);
void des_encrypt(uint64_t plaintext, uint64_t key, uint64_t *ciphertext);
void des_decrypt(uint64_t ciphertext, uint64_t key, uint64_t *plaintext);
uint64_t permute(uint64_t input, int *table, int n);
void print_binary(uint64_t num, int bits);
void print_hex(uint64_t num, int bits);
void print_separator();

int main() {
    printf("=== DES with 2-Bit Subkey Modification ===\n\n");
    
    // Test vectors
    uint64_t plaintext = 0x0123456789ABCDEF;  // Example plaintext
    uint64_t key = 0x133457799BBCDFF1;        // Example key
    uint64_t ciphertext, decrypted;
    uint64_t subkeys[ROUNDS];
    
    printf("Original DES Operation:\n");
    printf("Plaintext:  ");
    print_hex(plaintext, 64);
    printf("Key:        ");
    print_hex(key, 64);
    
    // Generate original subkeys
    generate_subkeys(key, subkeys);
    
    printf("\nOriginal Subkeys (first 3 and last 3):\n");
    for (int i = 0; i < 3; i++) {
        printf("K%d:  ", i + 1);
        print_hex(subkeys[i], 48);
    }
    printf("...\n");
    for (int i = 13; i < 16; i++) {
        printf("K%d: ", i + 1);
        print_hex(subkeys[i], 48);
    }
    
    // Original encryption
    des_encrypt(plaintext, key, &ciphertext);
    printf("\nOriginal Ciphertext: ");
    print_hex(ciphertext, 64);
    
    // Original decryption
    des_decrypt(ciphertext, key, &decrypted);
    printf("Decrypted:          ");
    print_hex(decrypted, 64);
    printf("Decryption: %s\n", (plaintext == decrypted) ? "SUCCESS" : "FAILED");
    
    print_separator();
    
    // Demonstrate 2-bit modification effects
    printf("\n2-Bit Subkey Modification Analysis:\n");
    print_separator();
    
    // Test different bit modifications
    int test_cases[][2] = {
        {1, 2},    // Modify bits 1 and 2
        {10, 20},  // Modify bits 10 and 20
        {30, 40},  // Modify bits 30 and 40
    };
    
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    for (int test = 0; test < num_tests; test++) {
        int bit1 = test_cases[test][0];
        int bit2 = test_cases[test][1];
        
        printf("\nTest Case %d: Modifying bits %d and %d in each subkey\n", 
               test + 1, bit1, bit2);
        
        // Create modified subkeys
        uint64_t modified_subkeys[ROUNDS];
        generate_subkeys(key, modified_subkeys);
        
        // Modify 2 bits in each subkey
        for (int round = 0; round < ROUNDS; round++) {
            modify_subkey_bits(modified_subkeys, round, bit1, bit2);
        }
        
        printf("Modified Subkeys (showing K1 and K16):\n");
        printf("Original K1:  ");
        print_hex(subkeys[0], 48);
        printf("Modified K1:  ");
        print_hex(modified_subkeys[0], 48);
        printf("Original K16: ");
        print_hex(subkeys[15], 48);
        printf("Modified K16: ");
        print_hex(modified_subkeys[15], 48);
        
        // Show bit differences
        printf("Bit differences in K1: ");
        int diff_count = 0;
        for (int i = 0; i < 48; i++) {
            uint64_t mask = 1ULL << (47 - i);
            if ((subkeys[0] & mask) != (modified_subkeys[0] & mask)) {
                printf("%d ", i + 1);
                diff_count++;
            }
        }
        printf("(%d bits changed)\n", diff_count);
    }
    
    print_separator();
    
    // Demonstrate avalanche effect with single subkey modification
    printf("\nAvalanche Effect - Single Subkey Modification:\n");
    print_separator();
    
    uint64_t single_modified_subkeys[ROUNDS];
    generate_subkeys(key, single_modified_subkeys);
    
    // Modify only one subkey (round 8)
    printf("Modifying only subkey K8, bits 5 and 25\n");
    modify_subkey_bits(single_modified_subkeys, 7, 5, 25);
    
    printf("Original K8:    ");
    print_hex(subkeys[7], 48);
    printf("Modified K8:    ");
    print_hex(single_modified_subkeys[7], 48);
    
    // Count bit differences in K8
    int diff_count_k8 = 0;
    for (int i = 0; i < 48; i++) {
        uint64_t mask = 1ULL << (47 - i);
        if ((subkeys[7] & mask) != (single_modified_subkeys[7] & mask)) {
            diff_count_k8++;
        }
    }
    printf("Bits changed in K8: %d/48\n", diff_count_k8);
    
    // Show effect on other subkeys (should be unchanged)
    int unchanged_count = 0;
    for (int i = 0; i < ROUNDS; i++) {
        if (i != 7 && subkeys[i] == single_modified_subkeys[i]) {
            unchanged_count++;
        }
    }
    printf("Other subkeys unchanged: %d/15\n", unchanged_count);
    
    print_separator();
    
    // Complete demonstration with all subkeys modified
    printf("\nComplete Demonstration - All Subkeys Modified:\n");
    print_separator();
    
    uint64_t all_modified_subkeys[ROUNDS];
    generate_subkeys(key, all_modified_subkeys);
    
    // Modify 2 bits in ALL subkeys
    for (int round = 0; round < ROUNDS; round++) {
        modify_subkey_bits(all_modified_subkeys, round, 3, 17);
    }
    
    printf("Comparison of All Subkeys (Original vs Modified):\n");
    printf("Round | Original Subkey | Modified Subkey | Bits Changed\n");
    printf("------|-----------------|-----------------|-------------\n");
    
    for (int i = 0; i < ROUNDS; i++) {
        printf("K%2d   | ", i + 1);
        print_hex(subkeys[i], 12);
        printf("      | ");
        print_hex(all_modified_subkeys[i], 12);
        printf("      | ");
        
        int changes = 0;
        for (int bit = 0; bit < 48; bit++) {
            uint64_t mask = 1ULL << (47 - bit);
            if ((subkeys[i] & mask) != (all_modified_subkeys[i] & mask)) {
                changes++;
            }
        }
        printf("%d\n", changes);
    }
    
    print_separator();
    
    printf("\nSecurity Analysis:\n");
    printf("- Each subkey modification creates 2^2 = 4 possible variations\n");
    printf("- With 16 rounds, total variations: 4^16 = 2^32 = 4,294,967,296\n");
    printf("- This demonstrates DES sensitivity to key changes\n");
    printf("- Small key modifications cause significant ciphertext changes\n");
    printf("- This avalanche effect is crucial for cryptographic security\n");
    
    return 0;
}

// Generate 16 subkeys from the main key
void generate_subkeys(uint64_t key, uint64_t subkeys[]) {
    // Apply PC1 permutation (64-bit to 56-bit)
    uint64_t pc1_key = permute(key, PC1, 56);
    
    uint32_t left = (pc1_key >> 28) & 0x0FFFFFFF;
    uint32_t right = pc1_key & 0x0FFFFFFF;
    
    for (int i = 0; i < ROUNDS; i++) {
        // Circular left shift
        left = ((left << shift_schedule[i]) | (left >> (28 - shift_schedule[i]))) & 0x0FFFFFFF;
        right = ((right << shift_schedule[i]) | (right >> (28 - shift_schedule[i]))) & 0x0FFFFFFF;
        
        // Combine and apply PC2
        uint64_t combined = ((uint64_t)left << 28) | right;
        subkeys[i] = permute(combined, PC2, 48);
    }
}

// Modify 2 specific bits in a subkey
void modify_subkey_bits(uint64_t subkeys[], int round, int bit1, int bit2) {
    if (round < 0 || round >= ROUNDS) return;
    
    // Ensure bits are in valid range (1-48 for subkeys)
    if (bit1 < 1 || bit1 > 48) bit1 = 1;
    if (bit2 < 1 || bit2 > 48) bit2 = 48;
    
    // Convert to 0-based indexing from left (MSB first)
    int pos1 = 48 - bit1;
    int pos2 = 48 - bit2;
    
    // Flip the specified bits using XOR
    uint64_t mask1 = 1ULL << pos1;
    uint64_t mask2 = 1ULL << pos2;
    subkeys[round] ^= (mask1 | mask2);
}

// Simplified DES encryption (conceptual implementation)
void des_encrypt(uint64_t plaintext, uint64_t key, uint64_t *ciphertext) {
    // Apply initial permutation
    uint64_t ip_text = permute(plaintext, IP, 64);
    
    // Simplified encryption for demonstration
    // In real DES, this would use 16 Feistel rounds with subkeys
    *ciphertext = ip_text ^ key;
    
    // Apply final permutation
    *ciphertext = permute(*ciphertext, FP, 64);
}

// Simplified DES decryption (conceptual implementation)
void des_decrypt(uint64_t ciphertext, uint64_t key, uint64_t *plaintext) {
    // Apply initial permutation (inverse of final permutation)
    uint64_t fp_text = permute(ciphertext, IP, 64);
    
    // Simplified decryption for demonstration
    *plaintext = fp_text ^ key;
    
    // Apply final permutation (inverse of initial permutation)
    *plaintext = permute(*plaintext, FP, 64);
}

// Generic permutation function
uint64_t permute(uint64_t input, int *table, int n) {
    uint64_t result = 0;
    for (int i = 0; i < n; i++) {
        int bit_pos = table[i] - 1;  // Convert to 0-based index
        if (input & (1ULL << (63 - bit_pos))) {
            result |= (1ULL << (n - 1 - i));
        }
    }
    return result;
}

// Print binary representation
void print_binary(uint64_t num, int bits) {
    for (int i = bits - 1; i >= 0; i--) {
        printf("%d", (num >> i) & 1);
        if (i % 8 == 0 && i != 0) printf(" ");
    }
    printf("\n");
}

// Print hexadecimal representation
void print_hex(uint64_t num, int bits) {
    int hex_digits = (bits + 3) / 4;
    if (bits == 64) {
        printf("0x%016lX\n", num);
    } else if (bits == 48) {
        // For 48-bit numbers, mask and print
        uint64_t masked = num & 0xFFFFFFFFFFFFULL;
        printf("0x%012lX\n", masked);
    } else {
        printf("0x%0*lX\n", hex_digits, num);
    }
}

// Print separator line
void print_separator() {
    printf("--------------------------------------------------\n");
}
